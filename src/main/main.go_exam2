package main

import (
	"fmt"
	"math/rand"
	"time"
)

func main() {
	const num int = 20
	// fmt.Println(num)
	var winRate = make([]int, 3)
	winRate[0] = 0
	winRate[1] = 0
	winRate[2] = 0
	for i := 0; i < 100; i++ {
		// card := make([]int, nCard)
		card := makeCard(num)
		mycard := shuffleCard(card)
		// fmt.Println(mycard)

		var player_1 = make([]int, 2)
		var player_2 = make([]int, 2)
		player_1[0] = mycard[0]
		player_2[0] = mycard[1]
		player_1[1] = mycard[2]
		player_2[1] = mycard[3]

		player_1_result, player_2_result, winner := competition(player_1, player_2)
		fmt.Println(player_1_result, player_2_result, winner)
		winRate[winner]++
	}

	fmt.Println(winRate)

	fmt.Printf("Player1 Win Rate : %0.2f %%\n", float32(winRate[1]))
	fmt.Printf("Player2 Win Rate : %0.2f %%\n", float32(winRate[2]))
	fmt.Printf("Draw Rate : %0.2f %%\n", float32(winRate[0]))

}

func competition(player_1 []int, player_2 []int) (int, int, int) {

	player_1_result := (player_1[0] + player_1[1]) % 10
	player_2_result := (player_2[0] + player_2[1]) % 10
	winner := 0
	if player_1_result > player_2_result {
		winner = 1
	} else if player_1_result == player_2_result {
		winner = 0
	} else {
		winner = 2
	}
	return player_1_result, player_2_result, winner
}

func shuffleCard(card []int) []int {

	num := len(card)
	var myCard = make([]int, num)
	var index = 0
	for {
		if index == num {
			break
		}
		s1 := rand.NewSource(time.Now().UnixNano())
		rand := rand.New(s1)
		randomNumber := rand.Intn(len(card))
		// fmt.Println(randomNumber)

		if card[randomNumber] != 0 {
			myCard[index] = card[randomNumber]
			card = append(card[:randomNumber], card[randomNumber+1:]...)
			// fmt.Println(card, myCard)
			index++
		} else {
			continue
		}

	}
	return myCard

}

func makeCard(num int) []int {

	var result = make([]int, num)
	for i := 0; i < num; i++ {
		result[i] = (i + 1) % 10
		if result[i] == 0 {
			result[i] = 10
		}
	}
	return result
}
